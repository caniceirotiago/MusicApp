Index: src/RockStar/RockstarIncManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package src.RockStar;\n\nimport src.GUIClassesSwing.GUIManager;\n\nimport javax.swing.*;\nimport java.io.Serializable;\nimport java.util.ArrayList;\n\npublic class RockstarIncManager  implements Serializable {\n    public static enum GENRE{ROCK,POP,CLASSIC,JAZZ,BLUES,HIP_HOP,ELETRONIC,FOLK,REGGAE,RELIGIOUS,TRADITIONAL} //Perceber qual o melhor sitio para colocar isto ; ver que está estatico neste momento\n    private ArrayList<User> userList;\n    private ArrayList<Music> musicList;\n    private User currentUser;\n    private GUIManager guiManager;\n\n    public RockstarIncManager(){\n        this.musicList = new ArrayList<>();\n        this.userList = new ArrayList<>();\n    }\n    //Novo método para iniciar a componente gráfica (É preciso estudar melhor este método)\n    public void startGUI() {\n        SwingUtilities.invokeLater(() -> {\n            guiManager = new GUIManager(RockstarIncManager.this);\n            guiManager.run();\n        });\n    }\n    //Métodos\n    public void run(){\n\n        //Criei um client só para experimentar Login.. depois é para apagar\n        Client tiago = new Client(\"as\",\"as\",\"as\",\"as\",0);\n        userList.add(tiago);\n        MusicCreator pedro = new MusicCreator(\"qw\",\"qw\",\"qw\",\"qw\",\"qw\");\n        userList.add(pedro);\n\n        //Playlist experiencia\n        tiago.newCollection(\"Rock Luso\");\n        tiago.newCollection(\"Mamonas Assassinas\");\n\n        //Musica Experiencia\n        Music m1 = new Music(\"Olá Joana\", GENRE.POP,pedro,0);\n        musicList.add(m1);\n        tiago.addMusicToCollection(m1,tiago.getAllCollections().get(0));\n        tiago.newMusicToAllCollection(m1);\n\n        Music m2 = new Music(\"Carolina\", GENRE.POP,pedro,0);\n        musicList.add(m2);\n        tiago.newMusicToAllCollection(m2);\n        tiago.addMusicToCollection(m2,tiago.getAllCollections().get(1));\n\n        Music m3 = new Music(\"Mariazinha\", GENRE.POP,pedro,0);\n        musicList.add(m3);\n        tiago.newMusicToAllCollection(m3);\n\n\n        //Inicia o método gráfico\n        startGUI();\n    }\n    public void loginAttempt(String username, String password, Boolean isMCreator, String pin){\n\n        boolean sucessfulLogin = false;\n        // O loop passa por todos os users compara se o user é cliente e o pedido de login é de cliente\n        //compara se o user é musiccreator e o pedido do login também o é e os restantes e se os restantes parâmetros são verdadeiros\n        for(User us : userList){\n            if(us instanceof Client && !isMCreator && us.getUsername().equals(username) && us.getPassword().equals(password)){\n            sucessfulLogin = true;\n            currentUser = us;\n            }\n            else if(us instanceof MusicCreator && isMCreator && us.getUsername().equals(username) && us.getPassword().equals(password)){\n                if(((MusicCreator)us).getPin().equals(pin)){\n                    sucessfulLogin = true;\n                    currentUser = us;\n                }\n            }\n        }\n        if(sucessfulLogin)  {\n           guiManager.sucessfullLogin(currentUser, isMCreator);\n            System.out.println(\"Successful Login\");\n        }\n        else {\n            System.out.println(\"Wrong Login\");\n            guiManager.unsuccessfulLogin();\n        }\n\n    }\n    //condicao que admite a entrada de alguem na aplicação se houver registo na user arraylist;\n    //acho que este método devia chamar se newRegistration\n    public void newUserAttempt(String name, String username, String password, String email, boolean isCreator, String pin){\n        boolean emailAlreadyExists = false;\n        boolean usernameAlreadyExists = false;\n\n\n        //Registo, validacao dados\n        //booleana final para se usar na criacao do user\n        boolean validRegistration = false;\n\n        //validação pin\n        boolean pinValido = false;\n        if (pin.isBlank() || pin.length() >8){\n            guiManager.unsuccessfulRegistration(5);\n        } else {\n            pinValido = true;\n        }\n\n        //username\n        //username tem no minimo 3 letras e maximo 15\n        boolean validUserName = false;\n        if (username.length()<3 || username.length()>10){\n            guiManager.unsuccessfulRegistration(4);\n        } else validUserName = true;\n\n\n        //email\n        boolean validEmail = false;\n        int indexAt = email.indexOf(\"@\");\n        int indexDotCom = email.indexOf(\".com\");\n        if (email.isBlank() ){\n            guiManager.unsuccessfulRegistration(3);\n        }\n        else if (indexAt != -1 && indexDotCom !=-1 && indexAt<indexDotCom && indexAt+1<indexDotCom){\n            validEmail = true;\n        } else {\n            System.out.println(\"email not valid\");\n            guiManager.unsuccessfulRegistration(3);\n        }\n        if (validEmail && validUserName){\n            validRegistration = true;\n        }\n\n\n        //This loop allows for an already created MusiCreator regist could make a new account as a Client and vice versa.\n        //It sends a code message for GUI to apply an error box \"1\" for invalid email and \"2\" for invalid username\n        for(User us : userList){\n            if(us.getEmail().equals(email)){\n                if((isCreator && us instanceof MusicCreator) || (!isCreator && us instanceof Client)){\n                    System.out.println(\"email already exists\");\n                    emailAlreadyExists = true;\n                    guiManager.unsuccessfulRegistration(1);\n                }\n            }\n            if(us.getUsername().equals(username)){\n                if((isCreator && us instanceof MusicCreator) || (!isCreator && us instanceof Client)){\n                    System.out.println(\"username already exists\");\n                    usernameAlreadyExists = true;\n                    guiManager.unsuccessfulRegistration(2);\n                }\n            }\n        }\n        //adicionar aqui booleana ou valor que confirme passagens entre barreiras\n        if(!emailAlreadyExists && !usernameAlreadyExists && validRegistration){\n            if(!isCreator) userList.add(new Client(name, username,password,email,0));\n            else if (pinValido) {\n                userList.add(new MusicCreator(name, username, password, email, pin));\n                System.out.println(\"New client created\");\n                guiManager.successfulRegistration();\n            }\n        }\n    }\n\n    public ArrayList<Music> listByOrder(ArrayList<Music> musicList){\n        //que ordem se coloca aqui? Faz se uma escolha dentro deste metodo, para ser alfabeticamente ou por data?\n        //tambem seria interessante ordenar por rating\n        return musicList;\n    }\n\n    public Search search(String searchTerm) {\n        //no enunciado pede apenas para pesquisar musica.. aqui já estou a complicar um bocado e a pesquisar por musica album e artista\n        //Este método cria objetos da classe Search, a classe search tem dois construtores:\n        //      1 - Lista de Musicas, lista de colecções de musica e lista de artistas (tipo de pesquisa apenas do utilizador normal )\n        //      2 - Lista de Musicas, lista de colecções do próprio criador (tipo de pesquisa apenas do criador de musica)\n        //Na primeira condição do presente método é tratada a pesquisa de utilizador normal onde são escolhidas as músicas,\n        //os albuns e as playlists publicas que corrreespondem ao termo da pesquisa.\n        //Na segunda é tratada a pesquisa se o utilizador for um criador de música, apenas retornará as músicas e albuns do próprio.\n        //\n        ArrayList<Music> foundMusics= new ArrayList<>();\n        ArrayList<MusicCollection> foundMusicCollections = new ArrayList<>();\n        ArrayList<MusicCreator> foundMusicCreators = new ArrayList<>();\n\n        if(currentUser instanceof Client){\n            //Pesquisa de Musica\n            for(Music m : musicList){\n                if(m.getName().toLowerCase().contains(searchTerm.toLowerCase())) foundMusics.add(m);\n            }\n            //Pesquisa de colleções de musica e artistas; apenas playlists publicas e todos os albuns.\n            for(User us :  userList){\n                if(us instanceof MusicCreator && us.name.toLowerCase().contains(searchTerm.toLowerCase())) foundMusicCreators.add((MusicCreator) us);\n                for(MusicCollection mc : us.getAllCollections()){\n                    if(mc.getName().toLowerCase().contains(searchTerm.toLowerCase()) && (mc instanceof Album || (mc instanceof Playlist && ((Playlist)mc).getPublic()))){\n                        foundMusicCollections.add(mc);\n                    }\n                }\n            }\n            return new Search(foundMusics,foundMusicCollections,foundMusicCreators);\n        } else {//se o current user for music creator apenas poderá pesquisar as proprias criações\n            for(Music m : musicList){\n                if(m.getMusicCreator().equals(currentUser) && m.getName().toLowerCase().contains(searchTerm.toLowerCase())) foundMusics.add(m);\n            }\n            //Pesquisa de albuns e artistas\n            for(User us :  userList){\n                if(us.equals(currentUser)){\n                    for(MusicCollection mc : us.getAllCollections()){\n                        if(mc.getName().toLowerCase().contains(searchTerm.toLowerCase())) foundMusicCollections.add(mc);\n                    }\n                };\n            }\n            return new Search(foundMusics,foundMusicCollections);\n        }\n    }\n    public void evaluateMusic(Music music, int evaluation){\n        //Chama método para adicionar avaliação na classe Music\n        music.addEvaluation((Client)currentUser, evaluation);\n    }\n    public void newRandomPlaylist(GENRE genre, int nOfMusics){\n        //este método cria uma playlist de forma aleatória por género musical para o utilizador normal\n        //Faz uso de um método acessorio chamado random IndexVector que retorna um vector de inteiros correspondente ao index\n        // de uma Arraylist de Musicas.\n        //O presente método pede um número de musicas e um género e devolve um arraylist\n        //Primeiro de tudo seleciona todas as músicas de determinado género e depois faz a seleção\n        ArrayList<Music> musicOfTheChosenGenre = new ArrayList<>();\n        ArrayList<Music> randomChosenMusic = new ArrayList<>();\n        for(Music m : musicList){\n            if(m.getGenre().equals(genre)) musicOfTheChosenGenre.add(m);\n        }\n        if(musicOfTheChosenGenre.size() < nOfMusics) System.out.println(\"there are not enought musics\");\n        else{\n            int[] listOfIndexes = randomIndexVector(nOfMusics, musicOfTheChosenGenre.size());\n            for(int i = 0; i < listOfIndexes.length; i++){\n                randomChosenMusic.add(musicOfTheChosenGenre.get(listOfIndexes[0]));\n            }\n            currentUser.newCollection(randomChosenMusic);\n        }\n    }\n    public int[] randomIndexVector(int SizeOfNewVector, int sizeOfSample){\n        //Escolhe de forma aleatoria um vector com indices num certo número de possibilidades. Pensar na utilização de um SEt Integer\n        //Ver metodo nweRandomPLaylist\n        int[] listOfIndexes = new int[SizeOfNewVector];\n        ArrayList<Integer> addedIndexes = new ArrayList<>();\n\n        for (int i = 0; i < SizeOfNewVector; i++) {\n            int randomIndex;\n            do {\n                randomIndex = (int) (Math.floor(Math.random() * sizeOfSample));\n            } while (addedIndexes.contains(randomIndex));\n\n            listOfIndexes[i] = randomIndex;\n            addedIndexes.add(randomIndex);\n        }\n        return listOfIndexes;\n    }\n    public void newCreationOfMusic(String name,GENRE genre, double price){\n        Music music = new Music(name, genre,(MusicCreator) currentUser, price);\n        musicList.add(music);\n        ((MusicCreator) currentUser).addCreatedMusic(music);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/RockStar/RockstarIncManager.java b/src/RockStar/RockstarIncManager.java
--- a/src/RockStar/RockstarIncManager.java	(revision 98c2f71e0dff5994ff4d8b91e9897967fd81ce90)
+++ b/src/RockStar/RockstarIncManager.java	(date 1702636574991)
@@ -148,11 +148,15 @@
         }
         //adicionar aqui booleana ou valor que confirme passagens entre barreiras
         if(!emailAlreadyExists && !usernameAlreadyExists && validRegistration){
-            if(!isCreator) userList.add(new Client(name, username,password,email,0));
-            else if (pinValido) {
-                userList.add(new MusicCreator(name, username, password, email, pin));
+            if(!isCreator) {
+                userList.add(new Client(name, username, password, email, 0));
                 System.out.println("New client created");
                 guiManager.successfulRegistration();
+            }
+            else if (isCreator){
+                if (pinValido) userList.add(new MusicCreator(name, username, password, email, pin));
+                System.out.println("New Music Creator created");
+                guiManager.successfulRegistration();
             }
         }
     }
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_21\" default=\"true\" project-jdk-name=\"20\" project-jdk-type=\"JavaSDK\">\n    <output url=\"file://$PROJECT_DIR$/out\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 98c2f71e0dff5994ff4d8b91e9897967fd81ce90)
+++ b/.idea/misc.xml	(date 1702636610311)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_21" default="true" project-jdk-name="20" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_20" default="true" project-jdk-name="20" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
